import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.junit.Before;
import org.junit.Test;

public class P06_IACC_01_Level1DBTransactionTest {

    private TestableLevel1DBTransaction dbTransaction;
    private ResultSet mockResultSet;

    @Before
    public void setUp() {
        dbTransaction = new TestableLevel1DBTransaction();
        mockResultSet = mock(ResultSet.class);
    }

    @Test
    public void testPopulateBeanObject_success() throws Exception {
        // Arrange: Setup mock ResultSet values
        when(mockResultSet.getString("ACCOUNT_ID")).thenReturn("ACC123");
        when(mockResultSet.getDouble("AMOUNT")).thenReturn(2500.50);
        when(mockResultSet.getString("CURRENCY")).thenReturn("USD");

        // Create a bean instance
        P06_IACC_01_Level1Bean bean = new P06_IACC_01_Level1Bean();

        // Act: Call the protected method through the subclass
        dbTransaction.callPopulateBeanObject(bean, mockResultSet);

        // Assert: Verify bean was populated correctly
        assertEquals("ACC123", bean.getAccountId());
        assertEquals(2500.50, bean.getAmount(), 0.001);
        assertEquals("USD", bean.getCurrency());
    }

    // Optional: Add negative or null case tests here...

    /**
     * Subclass to expose protected method for testing
     */
    private static class TestableLevel1DBTransaction extends P06_IACC_01_Level1DBTransaction {
        public void callPopulateBeanObject(Object bean, ResultSet rs) throws Exception {
            super.populateBeanObject(bean, rs);
        }
    }
}
