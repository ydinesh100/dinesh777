package com.hupparibas.atlentic.iacc.bopr.level2Test;

import com.bnpparibas.atlentic.iacc.bopr.level2.P06_IACC_01_BoprStringBuffer;
import org.junit.Before;
import org.junit.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Date;

import static org.junit.Assert.*;

// Test class
public class P06_IACC_01_BoprStringBufferTest {

    private P06_IACC_01_BoprStringBuffer boprStringBuffer;

    @Before
    public void setup() throws Exception {
        // Instantiate using reflection since constructor is protected
        Class<?> clazz = Class.forName("com.bnpparibas.atlentic.iacc.bopr.level2.P06_IACC_01_BoprStringBuffer");
        Constructor<?> constructor = clazz.getDeclaredConstructor();
        constructor.setAccessible(true);
        boprStringBuffer = (P06_IACC_01_BoprStringBuffer) constructor.newInstance();
    }

    @Test
    public void testAppendRecord_shouldAppendFormattedRecord() throws Exception {
        // Create a mock bean with dummy values
        P06_IACC_01_BoprRecordBeanMock recordBean = new P06_IACC_01_BoprRecordBeanMock();
        recordBean.setSenderServiceCode("ABC123");
        recordBean.setOperationReference("OPREF00001");
        recordBean.setCountryCode("IN");
        recordBean.setEffectiveDate("01012025");
        recordBean.setAmountCurrency("INR");
        recordBean.setCashflowDirection("FROM");
        recordBean.setAmount(123456.78);
        recordBean.setAmountInBranchCurrency(99999.99);

        // Use reflection to invoke protected appendRecord
        Method method = P06_IACC_01_BoprStringBuffer.class.getDeclaredMethod(
                "appendRecord",
                Class.forName("com.bnpparibas.atlentic.iacc.bopr.bean.P06_IACC_01_BoprRecordBean"),
                String.class
        );
        method.setAccessible(true);
        method.invoke(boprStringBuffer, recordBean, "INR");

        // Access internal buffer
        Field sbField = P06_IACC_01_BoprStringBuffer.class.getDeclaredField("g_o_sb");
        sbField.setAccessible(true);
        StringBuffer sb = (StringBuffer) sbField.get(boprStringBuffer);

        String result = sb.toString();

        // Assertions
        assertNotNull(result);
        assertTrue(result.contains("ABC123"));
        assertTrue(result.contains("OPREF00001"));
        assertTrue(result.contains("IN"));
        assertTrue(result.contains("01012025"));
        assertTrue(result.contains("INR"));
        assertTrue(result.contains("123456")); // part of amount
        assertTrue(result.contains("99999"));  // part of branch amount
    }

    // Stub/mock class for the bean
    public static class P06_IACC_01_BoprRecordBeanMock extends com.bnpparibas.atlentic.iacc.bopr.bean.P06_IACC_01_BoprRecordBean {

        public P06_IACC_01_BoprRecordBeanMock() {
            super(); // If your real class needs arguments, mock them here
        }

        // Setters (you can override or create public ones if needed)
        public void setSenderServiceCode(String val) { this.senderServiceCode = val; }
        public void setOperationReference(String val) { this.operationReference = val; }
        public void setCountryCode(String val) { this.countryCode = val; }
        public void setEffectiveDate(String val) { this.effectiveDate = val; }
        public void setAmountCurrency(String val) { this.amountCurrency = val; }
        public void setCashflowDirection(String val) { this.cashflowDirection = val; }
        public void setAmount(double val) { this.amount = val; }
        public void setAmountInBranchCurrency(Double val) { this.amountInBranchCurrency = val; }

        // Assumes fields like senderServiceCode, etc. exist and are accessible
        // If not, use reflection to set private fields
    }
}





}

    @Test
    public void testAppendRecord() throws Exception {
        Object recordBean = new MockBoprRecordBean();

        Method method = P06_IACC_01_BoprStringBuffer.class.getDeclaredMethod(
                "appendRecord",
                recordBean.getClass(),
                String.class
        );
        method.setAccessible(true);
        method.invoke(boprStringBuffer, recordBean, "INR");

        Field sbField = P06_IACC_01_BoprStringBuffer.class.getDeclaredField("g_o_sb");
        sbField.setAccessible(true);
        StringBuffer sb = (StringBuffer) sbField.get(boprStringBuffer);
        String result = sb.toString();

        assertNotNull(result);
        assertTrue(result.contains("ABC123"));
        assertTrue(result.contains("OPREF001"));
        assertTrue(result.contains("IN"));
        assertTrue(result.contains("01012025"));
        assertTrue(result.contains("INR"));
    }

    // ✅ Minimal mock version of the expected bean
    public static class MockBoprRecordBean {
        public String getSenderServiceCode() { return "ABC123"; }
        public String getOperationReference() { return "OPREF001"; }
        public String getCountryCode() { return "IN"; }
        public String getEffectiveDate() { return "01012025"; }
        public String getAmountCurrency() { return "INR"; }
        public String getCashflowDirection() { return "FROM"; }
        public double getAmount() { return 123456.78; }
        public Double getAmountInBranchCurrency() { return 99999.99; }




    @Test
    public void testAppendRecord_WithMockBean() throws Exception {
        // Mocking the bean
        P06_IACC_01_BoprRecordBean mockBean = mock(P06_IACC_01_BoprRecordBean.class);

        // Stubbing method responses
        when(mockBean.getSenderServiceCode()).thenReturn("SERV01");
        when(mockBean.getOperationReference()).thenReturn("OP1234567890");
        when(mockBean.getCountryCode()).thenReturn("FR");
        when(mockBean.getEffectiveDate()).thenReturn("01012025");
        when(mockBean.getAmountCurrency()).thenReturn("EUR");
        when(mockBean.getCashflowDirection()).thenReturn("FROM");
        when(mockBean.getAmount()).thenReturn(12345.67);
        when(mockBean.getAmountInBranchCurrency()).thenReturn(98765.43);

        // Call appendRecord
        Method method = P06_IACC_01_BoprStringBuffer.class.getDeclaredMethod("appendRecord", P06_IACC_01_BoprRecordBean.class, String.class);
        method.setAccessible(true);
        method.invoke(boprStringBuffer, mockBean, "INR");

        // Access private field g_o_sb
        Field sbField = P06_IACC_01_BoprStringBuffer.class.getDeclaredField("g_o_sb");
        sbField.setAccessible(true);
        StringBuffer resultBuffer = (StringBuffer) sbField.get(boprStringBuffer);
        String result = resultBuffer.toString();

        // Verify the content
        assertTrue(result.contains("SERV01"));
        assertTrue(result.contains("OP1234567890"));
        assertTrue(result.contains("FR"));
        assertTrue(result.contains("01012025"));
        assertTrue(result.contains("EUR"));
        assertTrue(result.contains("INR"));
    }




}


}

    @Test
    public void testAppendRecord_FullyCovered() throws Exception {
        // Mock the record bean
        P06_IACC_01_BoprRecordBean mockBean = mock(P06_IACC_01_BoprRecordBean.class);

        // Stub values
        when(mockBean.getSenderServiceCode()).thenReturn("SERV01");
        when(mockBean.getOperationReference()).thenReturn("OP1234567890");
        when(mockBean.getCountryCode()).thenReturn("FR");
        when(mockBean.getEffectiveDate()).thenReturn("01012025");
        when(mockBean.getCashflowDirection()).thenReturn("FROM");
        when(mockBean.getAmountCurrency()).thenReturn("EUR");
        when(mockBean.getAmount()).thenReturn(12345.67);
        when(mockBean.getAmountInBranchCurrency()).thenReturn(98765.43);

        // Call the method directly (no reflection)
        boprStringBuffer.appendRecord(mockBean, "INR");

        // Validate buffer content
        String result = boprStringBuffer.getBufferContent();

        // All these assertions now fall under coverage
        assertTrue(result.contains("SERV01"));
        assertTrue(result.contains("OP1234567890"));
        assertTrue(result.contains("FR"));
        assertTrue(result.contains("01012025"));
        assertTrue(result.contains("EUR"));
        assertTrue(result.contains("INR"));




@Test
public void testAppendRecord_FullyCovered() throws Exception {
    // Mock the record bean
    P06_IACC_01_BoprRecordBean mockBean = mock(P06_IACC_01_BoprRecordBean.class);

    // Correct date object
    SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");
    Date effectiveDate = sdf.parse("01012025");

    // Stub values
    when(mockBean.getSenderServiceCode()).thenReturn("SERV01");
    when(mockBean.getOperationReference()).thenReturn("OP1234567890");
    when(mockBean.getCountryCode()).thenReturn("FR");
    when(mockBean.getEffectiveDate()).thenReturn(effectiveDate);  // ✅ fix here
    when(mockBean.getCashflowDirection()).thenReturn("FROM");
    when(mockBean.getAmountCurrency()).thenReturn("EUR");
    when(mockBean.getAmount()).thenReturn(12345.67);
    when(mockBean.getAmountInBranchCurrency()).thenReturn(98765.43);

    boprStringBuffer.appendRecord(mockBean, "INR");

    String result = boprStringBuffer.getBufferContent();

    assertTrue(result.contains("SERV01"));
    assertTrue(result.contains("OP1234567890"));
    assertTrue(result.contains("FR"));
    assertTrue(result.contains("EUR"));
    assertTrue(result.contains("INR"));




}




}

    @Test
    public void testAppendRecord() throws Exception {
        // Mock the bean
        P06_IACC_01_BoprRecordBean mockBean = mock(P06_IACC_01_BoprRecordBean.class);

        // Prepare test data
        SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");
        Date date = sdf.parse("01012025");

        when(mockBean.getSenderServiceCode()).thenReturn("SERV01");
        when(mockBean.getOperationReference()).thenReturn("OP123456789012345678901234");
        when(mockBean.getCountryCode()).thenReturn("FR");
        when(mockBean.getEffectiveDate()).thenReturn(date);
        when(mockBean.getCashflowDirection()).thenReturn("FROM");
        when(mockBean.getAmountCurrency()).thenReturn("EUR");
        when(mockBean.getAmount()).thenReturn(12345.67);
        when(mockBean.getAmountInBranchCurrency()).thenReturn(98765.43);

        // Access and invoke the protected appendRecord method
        Method appendRecordMethod = P06_IACC_01_BoprStringBuffer.class.getDeclaredMethod(
            "appendRecord", P06_IACC_01_BoprRecordBean.class, String.class);
        appendRecordMethod.setAccessible(true);
        appendRecordMethod.invoke(boprStringBuffer, mockBean, "INR");

        // Validate the content
        String result = boprStringBuffer.getBufferContent(); // assuming you’ve exposed it

        assertTrue(result.contains("SERV01"));
        assertTrue(result.contains("OP1234567890"));
        assertTrue(result.contains("FR"));
        assertTrue(result.contains("EUR"));
        assertTrue(result.contains(" @Test
    public void testAppendRecord_usingReflection() throws Exception {
        // Mock the record bean
        P06_IACC_01_BoprRecordBean mockBean = mock(P06_IACC_01_BoprRecordBean.class);

        // Test data setup
        SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");
        Date testDate = sdf.parse("01012025");

        when(mockBean.getSenderServiceCode()).thenReturn("SERV01");
        when(mockBean.getOperationReference()).thenReturn("OP1234567890");
        when(mockBean.getCountryCode()).thenReturn("FR");
        when(mockBean.getEffectiveDate()).thenReturn(testDate);
        when(mockBean.getCashflowDirection()).thenReturn("FROM");
        when(mockBean.getAmountCurrency()).thenReturn("EUR");
        when(mockBean.getAmount()).thenReturn(12345.67);
        when(mockBean.getAmountInBranchCurrency()).thenReturn(98765.43);

        // Use reflection to invoke protected appendRecord method
        Method method = P06_IACC_01_BoprStringBuffer.class
                .getDeclaredMethod("appendRecord", P06_IACC_01_BoprRecordBean.class, String.class);
        method.setAccessible(true);
        method.invoke(boprStringBuffer, mockBean, "INR");

        // Use reflection to access the private StringBuffer field
        Field sbField = P06_IACC_01_BoprStringBuffer.class.getDeclaredField("g_o_sb");
        sbField.setAccessible(true);
        StringBuffer buffer = (StringBuffer) sbField.get(boprStringBuffer);
        String result = buffer.toString();

        // Assert that key fields are included in the result
        assertTrue(result.contains("SERV01"));
        assertTrue(result.contains("OP1234567890"));
        assertTrue(result.contains("FR"));
        assertTrue(result.contains("01012025"));
        assertTrue(result.contains("EUR"));
        assertTrue(result.contains("INR"));






@Test
public void testAppendRecord_withNullAmountInBranchCurrency() throws Exception {
    // Mock the record bean
    P06_IACC_01_BoprRecordBean mockBean = mock(P06_IACC_01_BoprRecordBean.class);

    SimpleDateFormat sdf = new SimpleDateFormat("ddMMyyyy");
    Date testDate = sdf.parse("01012025");

    when(mockBean.getSenderServiceCode()).thenReturn("SERV01");
    when(mockBean.getOperationReference()).thenReturn("OP987654321");
    when(mockBean.getCountryCode()).thenReturn("DE");
    when(mockBean.getEffectiveDate()).thenReturn(testDate);
    when(mockBean.getCashflowDirection()).thenReturn("TO");
    when(mockBean.getAmountCurrency()).thenReturn("USD");
    when(mockBean.getAmount()).thenReturn(5555.55);
    when(mockBean.getAmountInBranchCurrency()).thenReturn(null); // <<< trigger else

    // Use reflection to call the protected method
    Method method = P06_IACC_01_BoprStringBuffer.class
        .getDeclaredMethod("appendRecord", P06_IACC_01_BoprRecordBean.class, String.class);
    method.setAccessible(true);
    method.invoke(boprStringBuffer, mockBean, "INR");

    // Access private buffer
    Field sbField = P06_IACC_01_BoprStringBuffer.class.getDeclaredField("g_o_sb");
    sbField.setAccessible(true);
    StringBuffer buffer = (StringBuffer) sbField.get(boprStringBuffer);
    String result = buffer.toString();

    // Verify content includes known values
    assertTrue(result.contains("SERV01"));
    assertTrue(result.contains("OP987654321"));
    assertTrue(result.contains("USD"));
    assertTrue(result.contains("INR"));

    // This guarantees the else was hit: empty string of length 18
    assertTrue(result.contains(String.format("%-18s", "")));
}





















