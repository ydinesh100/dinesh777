package com.bnpparibas.atlentic.iacc.bopr.main.test;

import org.junit.jupiter.api.*;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.Permission;

import static org.junit.jupiter.api.Assertions.*;

class P06_IACC_01_MainTest {

    private static final String MAIN_CLASS = "com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main";

    @BeforeAll
    static void disableSystemExit() {
        System.setSecurityManager(new NoExitSecurityManager());
    }

    @AfterAll
    static void restoreSystemExit() {
        System.setSecurityManager(null); // Restore default
    }

    @Test
    void testInvalidDateFormatTriggersSystemExit() throws Exception {
        String[] testArgs = new String[]{"level1", "BE01", "invalid-date-format"};
        setStaticField("args", testArgs);

        Method execute = getPrivateExecuteMethod();

        ExitStatus exitStatus = assertThrows(ExitStatus.class, () -> {
            try {
                execute.invoke(null);
            } catch (Exception e) {
                // Ignore invocation exception caused by System.exit
            }
        });

        assertEquals(8, exitStatus.getStatusCode(), "Expected System.exit(8) to be called");
    }

    // ====== Reflection Utility Methods ======

    private void setStaticField(String fieldName, Object value) throws Exception {
        Class<?> clazz = Class.forName(MAIN_CLASS);
        Field field = clazz.getDeclaredField(fieldName);
        field.setAccessible(true);

        // Remove final modifier if needed
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);

        field.set(null, value);
    }

    private Method getPrivateExecuteMethod() throws Exception {
        Class<?> clazz = Class.forName(MAIN_CLASS);
        Method method = clazz.getDeclaredMethod("execute");
        method.setAccessible(true);
        return method;
    }

    // ====== Custom SecurityManager ======

    private static class NoExitSecurityManager extends SecurityManager {
        @Override
        public void checkPermission(Permission perm) {
            // Allow everything else
        }

        @Override
        public void checkExit(int status) {
            super.checkExit(status);
            throw new ExitStatus(status);
        }
    }

    // ====== Exception to Capture Exit ======

    private static class ExitStatus extends SecurityException {
        private final int statusCode;

        public ExitStatus(int statusCode) {
            super("System.exit(" + statusCode + ")");
            this.statusCode = statusCode;
        }

        public int getStatusCode() {
            return statusCode;
        }
    }
}
