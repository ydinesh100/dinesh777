package com.bnpparibas.atlentic.iacc.bopr.main.test;

import org.junit.jupiter.api.*;
import java.lang.reflect.*;
import java.util.Date;

import static org.junit.jupiter.api.Assertions.*;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class P06_IACC_01_MainTest {

    private SecurityManager originalSecurityManager;

    @BeforeAll
    void saveOriginalSecurityManager() {
        originalSecurityManager = System.getSecurityManager();
    }

    @AfterAll
    void restoreSecurityManager() {
        System.setSecurityManager(originalSecurityManager);
    }

    @BeforeEach
    void setUp() throws Exception {
        // Reset static fields if needed
        setStaticField("args", null);
        setStaticField("branch", null);
        setStaticField("eventTimestamp", null);
        setStaticField("beginDate", null);
        setStaticField("endDate", null);
        setStaticField("textFileName", null);
        setStaticField("action", null);
    }

    /**
     * Simulate invalid input date to trigger ParameterException
     */
    @Test
    void testInvalidDateFormatThrowsParameterException() throws Exception {
        String[] testArgs = new String[]{"level1", "BE01", "invalid-date"};

        setStaticField("args", testArgs);

        Method executeMethod = getPrivateExecuteMethod();

        assertThrows(InvocationTargetException.class, () -> {
            ExitTrapper.run(() -> executeMethod.invoke(null));
        }, "Expected exception due to invalid date format");
    }

    /**
     * Simulate System.exit by intercepting exit using a custom SecurityManager
     */
    @Test
    void testSystemExitTriggered() throws Exception {
        String[] testArgs = new String[]{"invalidAction", "BE01", "01/01/2024 00:00:00"};

        setStaticField("args", testArgs);

        Method executeMethod = getPrivateExecuteMethod();

        SecurityException exception = assertThrows(SecurityException.class, () -> {
            ExitTrapper.run(() -> executeMethod.invoke(null));
        });

        assertTrue(exception.getMessage().contains("Intercepted System.exit"), "Expected System.exit interception");
    }

    // ----- Utility Methods Below -----

    private Method getPrivateExecuteMethod() throws NoSuchMethodException {
        Class<?> clazz = Class.forName("com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main");
        Method method = clazz.getDeclaredMethod("execute");
        method.setAccessible(true);
        return method;
    }

    private void setStaticField(String fieldName, Object value) throws Exception {
        Class<?> clazz = Class.forName("com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main");
        Field field = clazz.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(null, value);
    }

    static class ExitTrapper extends SecurityManager {
        private static final SecurityManager original = System.getSecurityManager();

        public static void run(Runnable testLogic) {
            System.setSecurityManager(new ExitTrapper());
            try {
                testLogic.run();
            } catch (SecurityException e) {
                throw new SecurityException("Intercepted System.exit", e);
            } finally {
                System.setSecurityManager(original);
            }
        }

        @Override
        public void checkPermission(java.security.Permission perm) {
            // Allow all
        }

        @Override
        public void checkExit(int status) {
            throw new SecurityException("Intercepted System.exit(" + status + ")");
        }
    }
}
