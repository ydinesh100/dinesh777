import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Collections;
import java.util.List;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

@RunWith(MockitoJUnitRunner.class)
public class DatabaseProcessorTest {

    private static final Logger LOG = LoggerFactory.getLogger(DatabaseProcessorTest.class);

    @Mock
    private Connection dbConnection;

    @Mock
    private DataBaseTransaction dataBaseTransaction;

    @Mock
    private List<RecordBean> recordBeansList;

    @InjectMocks
    private DatabaseProcessor databaseProcessor;

    @Before
    public void setUp() {
        // Initialize mocks
        databaseProcessor.initializeDataBaseTransaction(dbConnection);
        when(databaseProcessor.getDataBaseTransaction()).thenReturn(dataBaseTransaction);
    }

    @Test
    public void testExecute_SuccessfulExecution() throws Exception {
        // Arrange
        when(GlobalAtlentic.getLoanIQConnection()).thenReturn(dbConnection);
        when(dbConnection.getAutoCommit()).thenReturn(false);
        when(dataBaseTransaction.getRecordsBeansList()).thenReturn(Collections.emptyList());

        // Act
        databaseProcessor.execute();

        // Assert
        verify(dbConnection).setAutoCommit(false);
        verify(dataBaseTransaction).getRecordsBeansList();
        verify(dbConnection).commit();
        verify(dbConnection, never()).rollback();
        verify(databaseProcessor).innerExecute();
        verify(databaseProcessor).applyCommit();
    }

    @Test
    public void testExecute_IOException_ThrowsExitApplicationException() throws Exception {
        // Arrange
        IOException ioException = new IOException("Connection failed");
        when(GlobalAtlentic.getLoanIQConnection()).thenThrow(ioException);

        // Act & Assert
        try {
            databaseProcessor.execute();
            fail("Expected P06_TACC_01_ExitApplicationException");
        } catch (P06_TACC_01_ExitApplicationException e) {
            assertEquals("Connection failed", e.getMessage());
            assertEquals(ioException, e.getCause());
        }
        verify(dbConnection, never()).rollback();
        verify(dbConnection, never()).commit();
        verify(databaseProcessor, never()).innerExecute();
    }

    @Test
    public void testExecute_SQLException_ThrowsExitApplicationException() throws Exception {
        // Arrange
        SQLException sqlException = new SQLException("Database error");
        when(GlobalAtlentic.getLoanIQConnection()).thenReturn(dbConnection);
        when(dataBaseTransaction.getRecordsBeansList()).thenThrow(sqlException);

        // Act & Assert
        try {
            databaseProcessor.execute();
            fail("Expected P06_TACC_01_ExitApplicationException");
        } catch (P06_TACC_01_ExitApplicationException e) {
            assertEquals("Database error", e.getMessage());
            assertEquals(sqlException, e.getCause());
        }
        verify(dbConnection).setAutoCommit(false);
        verify(dbConnection).rollback();
        verify(dbConnection, never()).commit();
        verify(databaseProcessor, never()).innerExecute();
    }

    @Test
    public void testExecute_CustomSQLException_ThrowsExitApplicationException() throws Exception {
        // Arrange
        P06_IACC_01_SQLException customException = new P06_IACC_01_SQLException("Custom SQL error");
        when(GlobalAtlentic.getLoanIQConnection()).thenReturn(dbConnection);
        when(dataBaseTransaction.getRecordsBeansList()).thenThrow(customException);

        // Act & Assert
        try {
            databaseProcessor.execute();
            fail("Expected P06_TACC_01_ExitApplicationException");
        } catch (P06_TACC_01_ExitApplicationException e) {
            assertEquals("Custom SQL error", e.getMessage());
            assertEquals(customException, e.getCause());
        }
        verify(dbConnection).setAutoCommit(false);
        verify(dbConnection).rollback();
        verify(dbConnection, never()).commit();
        verify(databaseProcessor, never()).innerExecute();
    }

    @Test
    public void testExecute_RollbackFails_StillThrowsOriginalException() throws Exception {
        // Arrange
        SQLException sqlException = new SQLException("Database error");
        SQLException rollbackException = new SQLException("Rollback failed");
        when(GlobalAtlentic.getLoanIQConnection()).thenReturn(dbConnection);
        when(dataBaseTransaction.getRecordsBeansList()).thenThrow(sqlException);
        doThrow(rollbackException).when(dbConnection).rollback();

        // Act & Assert
        try {
            databaseProcessor.execute();
            fail("Expected P06_TACC_01_ExitApplicationException");
        } catch (P06_TACC_01_ExitApplicationException e) {
            assertEquals("Database error", e.getMessage());
            assertEquals(sqlException, e.getCause());
            // Rollback exception is caught and not propagated
        }
        verify(dbConnection).setAutoCommit(false);
        verify(dbConnection).rollback();
        verify(dbConnection, never()).commit();
        verify(databaseProcessor, never()).innerExecute();
    }

    @Test
    public void testExecute_NullConnection_DoesNotAttemptRollback() throws Exception {
        // Arrange
        IOException ioException = new IOException("Connection failed");
        when(GlobalAtlentic.getLoanIQConnection()).thenThrow(ioException);

        // Act & Assert
        try {
            databaseProcessor.execute();
            fail("Expected P06_TACC_01_ExitApplicationException");
        } catch (P06_TACC_01_ExitApplicationException e) {
            assertEquals("Connection failed", e.getMessage());
            assertEquals(ioException, e.getCause());
        }
        verify(dbConnection, never()).rollback();
        verify(dbConnection, never()).commit();
        verify(databaseProcessor, never()).innerExecute();
    }
}






@RunWith(MockitoJUnitRunner.class)
public class ReportExecutorTest {

    @InjectMocks
    private ReportExecutor reportExecutor;

    @Mock
    private Connection mockConnection;

    @Mock
    private DataBaseTransaction mockTransaction;

    @Mock
    private List<RecordBean> mockRecordBeansList;

    @Before
    public void setup() throws Exception {
        PowerMockito.mockStatic(GlobalAtlantic.class);
        when(GlobalAtlantic.getLoanIQConnection()).thenReturn(mockConnection);
        when(mockConnection.getAutoCommit()).thenReturn(true);
    }

    @Test
    public void testExecute_SuccessfulExecution() throws Exception {
        doNothing().when(mockConnection).setAutoCommit(false);
        doNothing().when(mockConnection).commit();
        doNothing().when(reportExecutor).initializeDataBaseTransaction(mockConnection);
        when(reportExecutor.getDataBaseTransaction()).thenReturn(mockTransaction);
        when(mockTransaction.getRecordsBeansList()).thenReturn(mockRecordBeansList);
        doNothing().when(reportExecutor).innerExecute();
        when(reportExecutor.applyCommit()).thenReturn(false);

        reportExecutor.execute();

        verify(mockConnection).setAutoCommit(false);
        verify(mockConnection).commit();
    }

    @Test(expected = P06_TACC_01_ExitApplicationException.class)
    public void testExecute_IOException_ThrowsCustomException() throws Exception {
        doThrow(new IOException("IO error")).when(reportExecutor).initializeDataBaseTransaction(mockConnection);
        when(GlobalAtlantic.getLoanIQConnection()).thenReturn(mockConnection);

        reportExecutor.execute();
    }

    @Test
    public void testExecute_SQLException_DoesNotThrowCustomException() throws Exception {
        doThrow(new SQLException("SQL error")).when(reportExecutor).initializeDataBaseTransaction(mockConnection);
        when(GlobalAtlantic.getLoanIQConnection()).thenReturn(mockConnection);

        reportExecutor.execute(); // Should not throw P06_TACC_01_ExitApplicationException
    }
}
