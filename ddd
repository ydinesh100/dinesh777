package com.bnpparibas.atlentic.iacc.bopr.level;

import com.bnpparibas.atlentic.iacc.bopr.bean.P06_IACC_01_BoprRecordBean;
import com.bnpparibas.atlentic.iacc.bopr.resource.P86_IACC_01_PropertiesMgr;
import com.bnpparibas.atlentic.iacc.bopr.util.exception.P86_IACC_01_SQLException;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;

import java.sql.*;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class P06_IACC_01_Level1DBTransactionTest {

    @Mock private Connection mockConnection;
    @Mock private PreparedStatement mockPreparedStatement;
    @Mock private ResultSet mockResultSet;

    @InjectMocks
    private P06_IACC_01_Level1DBTransaction level1DBTransaction;

    // Provide concrete subclass since the original class is abstract
    private class TestLevel1DBTransaction extends P06_IACC_01_Level1DBTransaction {
        public TestLevel1DBTransaction(Connection conn) throws P86_IACC_01_SQLException {
            super(conn);
        }

        @Override
        protected void feedingRecordBean(P06_IACC_01_BoprRecordBean bean, ResultSet rs) throws SQLException {
            bean.setAmount(100.0);  // mock value
        }

        @Override
        protected String getSelectRecordsQueryKey() {
            return "mock.query.key";
        }

        @Override
        protected void feedRecordsBeansListPreparedStatement(PreparedStatement ps) throws SQLException {
            // no-op for test
        }
    }

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        level1DBTransaction = new TestLevel1DBTransaction(mockConnection);

        // Mock static method for P86_IACC_01_PropertiesMgr
        mockStatic(P86_IACC_01_PropertiesMgr.class);
        when(P86_IACC_01_PropertiesMgr.getQueryFromPropertiesFile("mock.query.key"))
                .thenReturn("SELECT * FROM MOCK_TABLE");

        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
        when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
    }

    @Test
    public void testGetRecordsBeansList_returnsValidBeans() throws Exception {
        // Simulate one row returned with positive amount
        when(mockResultSet.next()).thenReturn(true, false);

        // Let feedingRecordBean assign amount = 100, which passes filter (amount > 0)
        List<P06_IACC_01_BoprRecordBean> result = level1DBTransaction.getRecordsBeansList();

        assertEquals(1, result.size());
        assertEquals(100.0, result.get(0).getAmount(), 0.001);
    }

    @Test
    public void testGetRecordsBeansList_filtersOutZeroAmount() throws Exception {
        // Override feedingRecordBean to set amount = 0
        level1DBTransaction = new TestLevel1DBTransaction(mockConnection) {
            @Override
            protected void feedingRecordBean(P06_IACC_01_BoprRecordBean bean, ResultSet rs) throws SQLException {
                bean.setAmount(0.0);
            }
        };

        when(mockResultSet.next()).thenReturn(true, false);

        List<P06_IACC_01_BoprRecordBean> result = level1DBTransaction.getRecordsBeansList();
        assertTrue(result.isEmpty());
    }

    @Test(expected = P86_IACC_01_SQLException.class)
    public void testGetRecordsBeansList_throwsExceptionOnSQLException() throws Exception {
        when(mockConnection.prepareStatement(anyString())).thenThrow(new SQLException("DB Error"));
        level1DBTransaction.getRecordsBeansList();
    }
}
