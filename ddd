package com.bnpparibas.atlentic.iacc.bopr.main;

import static org.mockito.Mockito.*;

import java.lang.reflect.*;
import java.sql.SQLException;
import java.util.*;

import org.junit.*;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;

import com.bnpparibas.atlentic.iacc.bopr.exception.P06_IACC_01_ParameterException;
import com.bnpparibas.atlentic.iacc.bopr.exception.P06_IACC_01_ExitApplicationException;
import com.bnpparibas.atlentic.iacc.bopr.util.P06_IACC_01_PropertiesMgr;
import com.bnpparibas.common.utils.StringConverter;

@RunWith(MockitoJUnitRunner.class)
public class P06_IACC_01_MainTest {

    private Object mainInstance;
    private Class<?> mainClass;

    @Before
    public void setUp() throws Exception {
        mainClass = Class.forName("com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main");
        Constructor<?> constructor = mainClass.getDeclaredConstructor(String[].class);
        constructor.setAccessible(true);
        String[] args = new String[]{"levell", "BNP", "01/01/2025 120000", "01/01/2025", "02/01/2025"};
        mainInstance = constructor.newInstance((Object) args);
    }

    @Test
    public void testExecute_Level1_WithAllParams() throws Exception {
        try (
            MockedStatic<P06_IACC_01_PropertiesMgr> propMock = mockStatic(P06_IACC_01_PropertiesMgr.class);
            MockedStatic<StringConverter> convMock = mockStatic(StringConverter.class);
            MockedConstruction<?> level1Mock = mockConstruction(
                P06_IACC_01_Level1.class,
                (mock, context) -> when(mock.execute()).thenReturn(null)
            )
        ) {
            // Mocks
            propMock.when(P06_IACC_01_PropertiesMgr::getLevel1ActionName).thenReturn("levell");

            Date eventDate = new Date();
            Date beginDate = new Date(System.currentTimeMillis() - 86400000); // yesterday
            Date endDate = new Date();

            convMock.when(() -> StringConverter.StringToDate("01/01/2025 120000")).thenReturn(eventDate);
            convMock.when(() -> StringConverter.StringToDate("01/01/2025")).thenReturn(beginDate);
            convMock.when(() -> StringConverter.StringToDate("02/01/2025")).thenReturn(endDate);

            // Set private field
            Method executeMethod = mainClass.getDeclaredMethod("execute");
            executeMethod.setAccessible(true);
            executeMethod.invoke(mainInstance);
        }
    }

    @Test
    public void testExecute_Level2_WithFileName() throws Exception {
        Constructor<?> constructor = mainClass.getDeclaredConstructor(String[].class);
        constructor.setAccessible(true);
        String[] args = new String[]{"level2", "BNP", "01/01/2025 120000", "testFile.txt"};
        Object level2Instance = constructor.newInstance((Object) args);

        try (
            MockedStatic<P06_IACC_01_PropertiesMgr> propMock = mockStatic(P06_IACC_01_PropertiesMgr.class);
            MockedStatic<StringConverter> convMock = mockStatic(StringConverter.class);
            MockedConstruction<?> level2Mock = mockConstruction(
                P06_IACC_01_Level2.class,
                (mock, context) -> when(mock.execute()).thenReturn(null)
            )
        ) {
            propMock.when(P06_IACC_01_PropertiesMgr::getLevel2ActionName).thenReturn("level2");

            convMock.when(() -> StringConverter.StringToDate("01/01/2025 120000")).thenReturn(new Date());

            Method executeMethod = mainClass.getDeclaredMethod("execute");
            executeMethod.setAccessible(true);
            executeMethod.invoke(level2Instance);
        }
    }

    @Test(expected = InvocationTargetException.class)
    public void testExecute_InvalidParamCount_ShouldThrow() throws Exception {
        Constructor<?> constructor = mainClass.getDeclaredConstructor(String[].class);
        constructor.setAccessible(true);
        String[] args = new String[]{}; // empty
        Object invalidInstance = constructor.newInstance((Object) args);

        Method executeMethod = mainClass.getDeclaredMethod("execute");
        executeMethod.setAccessible(true);

        // This should throw InvocationTargetException wrapping ParameterException
        executeMethod.invoke(invalidInstance);
    }
}
