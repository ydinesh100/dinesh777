package com.bnpparibas.atlentic.iacc.bopr.level.test;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.util.Arrays;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import com.bnpparibas.atlentic.common.GlobalAtlentic;
import com.bnpparibas.atlentic.common.utils.DBUtils;
import com.bnpparibas.atlentic.iacc.bopr.bean.P06_IACC_01_BoprRecordBean;
import com.bnpparibas.atlentic.iacc.bopr.exception.P06_IACC_01_ExitApplicationException;
import com.bnpparibas.atlentic.iacc.bopr.exception.P86_IACC_01_SQLException;
import com.bnpparibas.atlentic.iacc.bopr.level.P06_IACC_01_DBTransaction;

import java.util.Collections;
import java.util.Date;
import java.util.List;

public class ExecuteMethodTest {

    private Object levelInstance;
    private Class<?> levelClass;

    private MockedStatic<GlobalAtlentic> globalAtlenticMock;
    private MockedStatic<DBUtils> dbUtilsMock;

    private Connection mockConnection;
    private P06_IACC_01_DBTransaction mockTransaction;

    @Before
    public void setUp() throws Exception {
        // Load the Level class dynamically
        levelClass = Class.forName("com.bnpparibas.atlentic.iacc.bopr.level.P06_IACC_01_Level");

        // Instantiate using reflection
        Constructor<?> constructor = levelClass.getDeclaredConstructor();
        constructor.setAccessible(true);
        levelInstance = constructor.newInstance();

        // Mock static methods
        globalAtlenticMock = Mockito.mockStatic(GlobalAtlentic.class);
        dbUtilsMock = Mockito.mockStatic(DBUtils.class);

        // Mocks
        mockConnection = mock(Connection.class);
        mockTransaction = mock(P06_IACC_01_DBTransaction.class);

        // Setup connection
        globalAtlenticMock.when(GlobalAtlentic::getLoanIQConnection).thenReturn(mockConnection);

        // Setup getDataBaseTransaction()
        Method setTransactionMethod = levelClass.getSuperclass().getDeclaredMethod("setDataBaseTransaction", P06_IACC_01_DBTransaction.class);
        setTransactionMethod.setAccessible(true);
        setTransactionMethod.invoke(levelInstance, mockTransaction);

        // Return dummy data
        List<P06_IACC_01_BoprRecordBean> dummyList = Arrays.asList(new P06_IACC_01_BoprRecordBean("BR01", new Date()));
        when(mockTransaction.getRecordsBeansList()).thenReturn(dummyList);

        // Stub applyCommit to true
        Method applyCommitMethod = levelClass.getSuperclass().getDeclaredMethod("applyCommit");
        applyCommitMethod.setAccessible(true);
        applyCommitMethod = spy(applyCommitMethod);

        // Stub innerExecute
        Method innerExecuteMethod = levelClass.getDeclaredMethod("innerExecute");
        innerExecuteMethod.setAccessible(true);
        // No-op for now, assume successful

        // Stub getLevelNumber
        Method getLevelNumberMethod = levelClass.getDeclaredMethod("getLevelNumber");
        getLevelNumberMethod.setAccessible(true);
        when(getLevelNumberMethod.invoke(levelInstance)).thenReturn(1);
    }

    @Test
    public void testExecute_success() throws Exception {
        Method executeMethod = levelClass.getDeclaredMethod("execute");
        executeMethod.setAccessible(true);

        // Run the method
        executeMethod.invoke(levelInstance);

        // Verify connection commit and close
        verify(mockConnection).setAutoCommit(false);
        verify(mockConnection).commit();

        dbUtilsMock.verify(() -> DBUtils.closeConnexion(mockConnection, null, null));
    }

    @After
    public void tearDown() {
        globalAtlenticMock.close();
        dbUtilsMock.close();
    }
}
