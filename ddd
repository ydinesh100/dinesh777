package com.bnpparibas.atlentic.iacc.bopr.level2;

import com.bnpparibas.atlentic.iacc.bopr.bean.P06_IACC_01_BoprRecordBean;
import com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main;
import com.bnpparibas.atlentic.iacc.bopr.util.exception.P06_IACC_01_ExitApplicationException;
import com.bnpparibas.atlentic.iacc.bopr.util.exception.P06_IACC_01_SQLException;
import org.junit.*;
import org.junit.rules.TemporaryFolder;
import org.mockito.*;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class P06_IACC_01_Level2Test {

    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    @Mock
    private P06_IACC_01_Level2DBTransaction mockTransaction;

    @InjectMocks
    private P06_IACC_01_Level2 level2;

    private List<P06_IACC_01_BoprRecordBean> dummyRecords;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        // Prepare dummy record list
        dummyRecords = new ArrayList<>();
        dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));
        dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));

        // Set private field g_o_recordBeansList
        Field recordListField = level2.getClass().getSuperclass().getDeclaredField("g_o_recordBeansList");
        recordListField.setAccessible(true);
        recordListField.set(level2, dummyRecords);

        // Set mock DB transaction
        when(mockTransaction.getBranchCurrency()).thenReturn("USD");
        Field dbField = level2.getClass().getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
        dbField.setAccessible(true);
        dbField.set(level2, mockTransaction);

        // Set environment variable (hack via reflection)
        String tempDir = folder.newFolder("liq-output").getAbsolutePath() + "/";
        setEnv("LIQFilesOutDirectory", tempDir);

        // Set text file name from P06_IACC_01_Main
        Field fileNameField = P06_IACC_01_Main.class.getDeclaredField("g_s_textFileName");
        fileNameField.setAccessible(true);
        fileNameField.set(null, "test_output.txt");
    }

    @Test
    public void testInnerExecuteCreatesFile() throws IOException, P06_IACC_01_SQLException, P06_IACC_01_ExitApplicationException {
        level2.innerExecute();

        File expectedFile = new File(System.getenv("LIQFilesOutDirectory") + "test_output.txt");
        assertTrue("Expected file should be created", expectedFile.exists());
        assertTrue("Expected file should not be empty", expectedFile.length() > 0);
    }

    @Test
    public void testGetLevelNumber() {
        assertEquals(2, level2.getLevelNumber());
    }

    @Test
    public void testApplyCommitReturnsFalse() {
        assertFalse(level2.applyCommit());
    }

    @Test
    public void testInitializeDataBaseTransactionSetsTransaction() throws P06_IACC_01_SQLException {
        Connection mockConn = mock(Connection.class);
        level2.initializeDataBaseTransaction(mockConn);

        Field dbField;
        try {
            dbField = level2.getClass().getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
            dbField.setAccessible(true);
            Object obj = dbField.get(level2);
            assertNotNull(obj);
            assertTrue(obj instanceof P06_IACC_01_Level2DBTransaction);
        } catch (Exception e) {
            fail("Reflection failed: " + e.getMessage());
        }
    }

    // Utility to set environment variable (hack for testing only)
    private void setEnv(String key, String value) throws Exception {
        Map<String, String> newenv = new HashMap<>(System.getenv());
        newenv.put(key, value);
        Class<?> processEnvironment = Class.forName("java.lang.ProcessEnvironment");
        Field theEnvironmentField = processEnvironment.getDeclaredField("theEnvironment");
        theEnvironmentField.setAccessible(true);
        ((Map<String, String>) theEnvironmentField.get(null)).putAll(newenv);
        Field theCaseInsensitiveEnvironmentField = processEnvironment.getDeclaredField("theCaseInsensitiveEnvironment");
        theCaseInsensitiveEnvironmentField.setAccessible(true);
        ((Map<String, String>) theCaseInsensitiveEnvironmentField.get(null)).putAll(newenv);
    }
}


@Test
public void testGetTextFileContent_UsesBranchCurrencyReflectively() throws Exception {
    // Set dummy record list
    List<P06_IACC_01_BoprRecordBean> records = new ArrayList<>();
    records.add(mock(P06_IACC_01_BoprRecordBean.class));

    // Set private field g_o_recordBeansList
    Field recordListField = level2.getClass().getSuperclass().getDeclaredField("g_o_recordBeansList");
    recordListField.setAccessible(true);
    recordListField.set(level2, records);

    // Create real DBTransaction instance
    P06_IACC_01_Level2DBTransaction realTransaction = new P06_IACC_01_Level2DBTransaction(mock(Connection.class));

    // Use reflection to set internal private field g_o_dataBaseTransaction
    Field dbField = level2.getClass().getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
    dbField.setAccessible(true);
    dbField.set(level2, realTransaction);

    // Use reflection to call private getBranchCurrency()
    Method method = realTransaction.getClass().getDeclaredMethod("getBranchCurrency");
    method.setAccessible(true);
    String currency = (String) method.invoke(realTransaction);
    assertNotNull(currency);  // Optional: assert the value returned

    // Now test getTextFileContent() — it will use that branch currency
    Method getTextMethod = level2.getClass().getDeclaredMethod("getTextFileContent");
    getTextMethod.setAccessible(true);
    String content = (String) getTextMethod.invoke(level2);
    assertNotNull(content);  // Should contain header + footer, maybe more if logic @Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);

    // Prepare dummy record list
    dummyRecords = new ArrayList<>();
    dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));
    dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));

    // Set private field g_o_recordBeansList
    Field recordListField = level2.getClass().getSuperclass().getDeclaredField("g_o_recordBeansList");
    recordListField.setAccessible(true);
    recordListField.set(level2, dummyRecords);

    // Use a test subclass to override getBranchCurrency()
    P06_IACC_01_Level2DBTransaction testTransaction = new TestLevel2DBTransaction();
    Field dbField = level2.getClass().getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
    dbField.setAccessible(true);
    dbField.set(level2, testTransaction);

    // Set environment variable (hack via reflection)
    String tempDir = folder.newFolder("liq-output").getAbsolutePath() + "/";
    setEnv("LIQFilesOutDirectory", tempDir);

    // Set text file name from P06_IACC_01_Main
    Field fileNameField = P06_IACC_01_Main.class.getDeclaredField("g_s_textFileName");
    fileNameField.setAccessible(true);
    fileNameField.set(null, "test_output.txt");
}


private TestLevel2 level2;

@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);

    level2 = new TestLevel2();  // <-- Use test subclass here

    // Prepare dummy record list
    dummyRecords = new ArrayList<>();
    dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));
    dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));

    // Set private field g_o_recordBeansList
    Field recordListField = level2.getClass().getSuperclass().getDeclaredField("g_o_recordBeansList");
    recordListField.setAccessible(true);
    recordListField.set(level2, dummyRecords);

    // Set mock DB transaction (even if unused here)
    Field dbField = level2.getClass().getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
    dbField.setAccessible(true);
    dbField.set(level2, mock(P06_IACC_01_Level2DBTransaction.class));

    // Set environment variable for file output
    String tempDir = folder.newFolder("liq-output").getAbsolutePath() + "/";
    setEnv("LIQFilesOutDirectory", tempDir);

    // Set static text file name
    Field fileNameField = P06_IACC_01_Main.class.getDeclaredField("g_s_textFileName");
    fileNameField.setAccessible(true);
    fileNameField.set(null, "test_output.txt");
}

public class P06_IACC_01_Level2Test {

    private List<P06_IACC_01_BoprRecordBean> dummyRecords;
    private TestLevel2 level2;

    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    // ✅ Test subclass of the class under test
    private static class TestLevel2 extends P06_IACC_01_Level2 {
        @Override
        protected String getTextFileContent() {
            return "HEADER\nRECORD1\nRECORD2\nFOOTER";
        }
    }

    @Before
    public void setUp() throws Exception {
        level2 = new TestLevel2();

        // Mock record list
        dummyRecords = new ArrayList<>();
        dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));
        dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));

        // Set private field g_o_recordBeansList
        Field recordListField = level2.getClass().getSuperclass().getDeclaredField("g_o_recordBeansList");
        recordListField.setAccessible(true);
        recordListField.set(level2, dummyRecords);

        // Set mock DB transaction — even if unused now
        Field dbField = level2.getClass().getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
        dbField.setAccessible(true);
        dbField.set(level2, mock(P06_IACC_01_Level2DBTransaction.class));

        // Set env variable
        String tempDir = folder.newFolder("liq-output").getAbsolutePath() + "/";
        setEnv("LIQFilesOutDirectory", tempDir);

        // Set text file name (static field)
        Field fileNameField = P06_IACC_01_Main.class.getDeclaredField("g_s_textFileName");
        fileNameField.setAccessible(true);
        fileNameField.set(null, "test_output.txt");
    }

    @Test
    public void testInnerExecute_WritesExpectedFile() throws Exception {
        level2.innerExecute();  // Writes file using overridden getTextFileContent()

        File outputFile = new File(System.getenv("LIQFilesOutDirectory") + "test_output.txt");
        assertTrue(outputFile.exists());

        String content = new String(Files.readAllBytes(outputFile.toPath()));
        assertTrue(content.contains("HEADER"));
        assertTrue(content.contains("RECORD1"));
        assertTrue(content.contains("FOOTER"));
    }

    // Utility to set env variable using reflection (works in most test JVMs)
    private static void setEnv(String key, String value) throws Exception {
        Map<String, String> newenv = new HashMap<>();
        newenv.put(key, value);
        Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment");
        Field theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment");
        theEnvironmentField.setAccessible(true);
        ((Map<String, String>) theEnvironmentField.get(null)).putAll(newenv);
        Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment");
        theCaseInsensitiveEnvironmentField.setAccessible(true);
        ((Map<String, String>) theCaseInsensitiveEnvironmentField.get(null)).putAll(newenv);
    }
}







