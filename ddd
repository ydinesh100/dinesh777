package com.bnpparibas.atlentic.iacc.bopr.main.test;

public class NoExitSecurityManager {

    private static int exitStatus = -1;

    public static void setupExitInterceptor() {
        System.setSecurityManager(new SecurityManager() {
            @Override
            public void checkExit(int status) {
                exitStatus = status;
                throw new ExitException(status);
            }

            @Override
            public void checkPermission(java.security.Permission perm) {
                // allow everything else
            }
        });
    }

    public static void reset() {
        System.setSecurityManager(null);
        exitStatus = -1;
    }

    public static class ExitException extends SecurityException {
        public final int status;

        public ExitException(int status) {
            super("System.exit() called with status: " + status);
            this.status = status;
        }
    }

    public static int getExitStatus() {
        return exitStatus;
    }
}




package com.bnpparibas.atlentic.iacc.bopr.main.test;

import com.bnpparibas.atlentic.common.GlobalAtlentic;
import com.bnpparibas.atlentic.common.Pee_IACC_00_Utility;
import com.bnpparibas.atlentic.common.gen.string.utilities.StringConverter;
import com.bnpparibas.atlentic.iacc.bopr.level1.P06_IACC_01_Level1;
import com.bnpparibas.atlentic.iacc.bopr.level2.P06_IACC_01_Level2;
import com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main;
import com.bnpparibas.atlentic.iacc.bopr.resource.P06_IACC_01_PropertiesMgr;

import org.junit.jupiter.api.*;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;

import java.lang.reflect.Method;
import java.sql.Connection;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class P06_IACC_01_MainTest {

    @BeforeAll
    void setupSecurityManager() {
        NoExitSecurityManager.setupExitInterceptor();
    }

    @AfterAll
    void tearDownSecurityManager() {
        NoExitSecurityManager.reset();
    }

    private void invokeExecute() throws Exception {
        Method executeMethod = P06_IACC_01_Main.class.getDeclaredMethod("execute");
        executeMethod.setAccessible(true);
        executeMethod.invoke(null);
    }

    @Test
    void testExecute_Level1_WithValidArguments() throws Exception {
        String[] args = { "level1", "BEFOR", "01/01/2025 00:00:00", "01/01/2025 00:00:00", "02/01/2025 00:00:00" };
        P06_IACC_01_Main.set_args(args);

        try (
            MockedStatic<GlobalAtlentic> globalMock = mockStatic(GlobalAtlentic.class);
            MockedStatic<Pee_IACC_00_Utility> utilMock = mockStatic(Pee_IACC_00_Utility.class);
            MockedStatic<StringConverter> converterMock = mockStatic(StringConverter.class);
            MockedStatic<P06_IACC_01_PropertiesMgr> propMock = mockStatic(P06_IACC_01_PropertiesMgr.class);
            MockedConstruction<P06_IACC_01_Level1> level1Mock = mockConstruction(P06_IACC_01_Level1.class, (mock, context) -> doNothing().when(mock).execute())
        ) {
            converterMock.when(() -> StringConverter.StringToDate(anyString()))
                .thenReturn(new java.util.Date());

            globalMock.when(GlobalAtlentic::getLoanIQConnection)
                      .thenReturn(mock(Connection.class));

            utilMock.when(() -> Pee_IACC_00_Utility.getAtlIntfDateByBranch(any(), any()))
                    .thenReturn(Map.of(
                        "INTF_SYSTEM_BEGIN_DATE", "01/01/2025 00:00:00",
                        "INTF_SYSTEM_END_DATE", "02/01/2025 00:00:00",
                        "INTF_EVENT_DATE", "01/01/2025 00:00:00"
                    ));

            propMock.when(P06_IACC_01_PropertiesMgr::getLevel1ActionName)
                    .thenReturn("level1");

            ExitException exit = assertThrows(NoExitSecurityManager.ExitException.class, this::invokeExecute);
            assertEquals(0, exit.status, "Expected System.exit(0) to be called");

            assertEquals(1, level1Mock.constructed().size(), "Level1 should be executed");
        }
    }

    @Test
    void testExecute_InvalidArgs_ShouldExitWithError() throws Exception {
        String[] args = {}; // empty args
        P06_IACC_01_Main.set_args(args);

        ExitException exit = assertThrows(NoExitSecurityManager.ExitException.class, this::invokeExecute);
        assertEquals(8, exit.status, "Expected System.exit(8) for invalid args");
    }
}


