package com.bnpparibas.atlentic.iacc.bopr.main.test;

import org.junit.jupiter.api.*;
import java.lang.reflect.*;

import static org.junit.jupiter.api.Assertions.*;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class P06_IACC_01_MainTest {

    private SecurityManager originalSecurityManager;

    @BeforeAll
    void saveOriginalSecurityManager() {
        originalSecurityManager = System.getSecurityManager();
    }

    @AfterAll
    void restoreOriginalSecurityManager() {
        System.setSecurityManager(originalSecurityManager);
    }

    @BeforeEach
    void resetStaticFields() throws Exception {
        setStaticField("args", null);
        setStaticField("branch", null);
        setStaticField("eventTimestamp", null);
        setStaticField("beginDate", null);
        setStaticField("endDate", null);
        setStaticField("textFileName", null);
        setStaticField("action", null);
    }

    @Test
    void testInvalidDateFormatThrowsParameterException() {
        String[] testArgs = new String[]{"level1", "BE01", "invalid-date"};
        setStaticField("args", testArgs);

        Method executeMethod = getPrivateExecuteMethod();

        ExitTrapper.run(() -> {
            try {
                executeMethod.invoke(null);
                fail("Expected an exception due to invalid date format");
            } catch (InvocationTargetException e) {
                Throwable cause = e.getCause();
                assertNotNull(cause);
                assertTrue(cause.getMessage().toLowerCase().contains("date format"),
                        "Expected date format exception, but got: " + cause.getMessage());
            } catch (IllegalAccessException e) {
                fail("Could not access execute() method: " + e.getMessage());
            }
        });
    }

    @Test
    void testSystemExitOnInvalidArgs() {
        String[] testArgs = new String[]{"invalidAction", "BE01", "01/01/2025 00:00:00"};
        setStaticField("args", testArgs);

        Method executeMethod = getPrivateExecuteMethod();

        SecurityException exception = assertThrows(SecurityException.class, () -> {
            ExitTrapper.run(() -> {
                try {
                    executeMethod.invoke(null);
                } catch (Exception e) {
                    throw new RuntimeException("Invocation failed", e);
                }
            });
        });

        assertTrue(exception.getMessage().contains("Intercepted System.exit"),
                "Expected System.exit interception");
    }

    // ================= Utility Methods ===================

    private Method getPrivateExecuteMethod() {
        try {
            Class<?> clazz = Class.forName("com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main");
            Method method = clazz.getDeclaredMethod("execute");
            method.setAccessible(true);
            return method;
        } catch (Exception e) {
            throw new RuntimeException("Could not access execute() method", e);
        }
    }

    private void setStaticField(String fieldName, Object value) {
        try {
            Class<?> clazz = Class.forName("com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main");
            Field field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(null, value);
        } catch (Exception e) {
            throw new RuntimeException("Could not set static field: " + fieldName, e);
        }
    }

    /**
     * SecurityManager wrapper to trap System.exit()
     */
    static class ExitTrapper extends SecurityManager {
        private static final SecurityManager original = System.getSecurityManager();

        public static void run(Runnable runnable) {
            System.setSecurityManager(new ExitTrapper());
            try {
                runnable.run();
            } finally {
                System.setSecurityManager(original);
            }
        }

        @Override
        public void checkPermission(java.security.Permission perm) {
            // Allow all other permissions
        }

        @Override
        public void checkExit(int status) {
            throw new SecurityException("Intercepted System.exit(" + status + ")");
        }
    }
}
