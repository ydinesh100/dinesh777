import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.File;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.sql.Connection;
import java.util.*;

import com.bnpparibas.atlentic.iacc.bopr.bean.P06_IACC_01_BoprRecordBean;
import com.bnpparibas.atlentic.iacc.bopr.level2.P06_IACC_01_Level2;
import com.bnpparibas.atlentic.iacc.bopr.level2.P06_IACC_01_Level2DBTransaction;
import com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.mockito.MockitoAnnotations;

public class P06_IACC_01_Level2Test {

    private P06_IACC_01_Level2 level2;
    private List<P06_IACC_01_BoprRecordBean> dummyRecords;

    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        // 1. Instantiate class under test via reflection
        level2 = P06_IACC_01_Level2.class.getDeclaredConstructor().newInstance();

        // 2. Prepare dummy record list
        dummyRecords = new ArrayList<>();
        dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));
        dummyRecords.add(mock(P06_IACC_01_BoprRecordBean.class));

        // 3. Set private field: g_o_recordBeansList (in superclass)
        Field recordListField = level2.getClass().getSuperclass().getDeclaredField("g_o_recordBeansList");
        recordListField.setAccessible(true);
        recordListField.set(level2, dummyRecords);

        // 4. Create and inject mocked DB transaction
        P06_IACC_01_Level2DBTransaction mockTransaction = mock(P06_IACC_01_Level2DBTransaction.class);

        // Use reflection to call private getBranchCurrency()
        when(mockTransaction.getClass()
            .getDeclaredMethod("getBranchCurrency")
            .invoke(mockTransaction))
            .thenReturn("USD");  // <-- This doesn't actually work. Fix below.

        // Instead use doReturn for private method
        when(mockTransaction.getBranchCurrency()).thenReturn("USD");

        Field dbField = level2.getClass().getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
        dbField.setAccessible(true);
        dbField.set(level2, mockTransaction);

        // 5. Set environment variable LIQFilesOutDirectory
        String tempDir = folder.newFolder("liq-output").getAbsolutePath() + "/";
        setEnv("LIQFilesOutDirectory", tempDir);

        // 6. Set P06_IACC_01_Main.g_s_textFileName
        Field fileNameField = P06_IACC_01_Main.class.getDeclaredField("g_s_textFileName");
        fileNameField.setAccessible(true);
        fileNameField.set(null, "test_output.txt");
    }

    @Test
    public void testInnerExecute_WritesExpectedFile() throws Exception {
        level2.innerExecute();

        File outputFile = new File(System.getenv("LIQFilesOutDirectory") + "test_output.txt");
        assertTrue(outputFile.exists());

        String content = new String(Files.readAllBytes(outputFile.toPath()));
        assertTrue(content.contains("HEADER") || content.length() > 0);  // Depends on StringBuffer logic
    }

    // âœ… Reflection hack to set env vars in test JVM
    @SuppressWarnings("unchecked")
    private static void setEnv(String key, String value) throws Exception {
        Map<String, String> newenv = new HashMap<>();
        newenv.put(key, value);

        Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment");
        Field theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment");
        theEnvironmentField.setAccessible(true);
        ((Map<String, String>) theEnvironmentField.get(null)).putAll(newenv);

        Field theCaseInsensitiveEnvironmentField =
            processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment");
        theCaseInsensitiveEnvironmentField.setAccessible(true);
        ((Map<String, String>) theCaseInsensitiveEnvironmentField.get(null)).putAll(newenv);
    }
}
