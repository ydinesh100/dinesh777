package com.bnpparibas.atlentic.iacc.bopr.level2Test;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.bnpparibas.atlentic.iacc.bopr.bean.P06_IACC_01_BoprRecordBean;
import com.bnpparibas.atlentic.iacc.bopr.level2.P06_IACC_01_BoprStringBuffer;
import com.bnpparibas.atlentic.iacc.bopr.level2.P86_IACC_01_Level2;
import com.bnpparibas.atlentic.iacc.bopr.level2.P06_IACC_01_Level2DBTransaction;

public class P06_IACC_01_Level2Test {

    @InjectMocks
    private P86_IACC_01_Level2 level2;

    @Mock
    private P06_IACC_01_Level2DBTransaction dbTransaction;

    @Mock
    private P06_IACC_01_BoprRecordBean recordBean;

    @Mock
    private Connection connection;

    private List<P06_IACC_01_BoprRecordBean> recordBeansList;

    private String branchCurrency = "EUR";

    private P06_IACC_01_BoprStringBuffer stringBuffer;

    @Before
    public void setup() throws Exception {
        MockitoAnnotations.initMocks(this);

        // Setup fake DB transaction with a fixed currency
        when(dbTransaction.getBranchCurrency()).thenReturn(branchCurrency);

        // Inject into superclass fields via reflection
        Field dbTxField = P86_IACC_01_Level2.class.getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
        dbTxField.setAccessible(true);
        dbTxField.set(level2, dbTransaction);

        recordBeansList = new ArrayList<>();
        recordBeansList.add(recordBean);

        Field listField = P86_IACC_01_Level2.class.getSuperclass().getDeclaredField("g_o_recordBeansList");
        listField.setAccessible(true);
        listField.set(level2, recordBeansList);

        // Mock recordBean values
        when(recordBean.getSenderServiceCode()).thenReturn("123456");
        when(recordBean.getOperationReference()).thenReturn("OP_REF_123");
        when(recordBean.getCountryCode()).thenReturn("FR");
        when(recordBean.getEffectiveDate()).thenReturn(new Date());
        when(recordBean.getCashflowDirection()).thenReturn("FROM");
        when(recordBean.getAmountCurrency()).thenReturn("EUR");
        when(recordBean.getAmount()).thenReturn(1000.0);
        when(recordBean.getAmountInBranchCurrency()).thenReturn(1000.0);

        // Instantiate buffer manually for toString test
        stringBuffer = new P06_IACC_01_BoprStringBuffer();
    }

    @Test
    public void testApplyCommit() throws Exception {
        Method method = P86_IACC_01_Level2.class.getDeclaredMethod("applyCommit");
        method.setAccessible(true);
        boolean result = (boolean) method.invoke(level2);
        assertFalse(result);
    }

    @Test
    public void testGetLevelNumber() throws Exception {
        Method method = P86_IACC_01_Level2.class.getDeclaredMethod("getLevelNumber");
        method.setAccessible(true);
        int level = (int) method.invoke(level2);
        assertEquals(2, level);
    }

    @Test
    public void testInitializeDataBaseTransaction() throws Exception {
        Method method = P86_IACC_01_Level2.class.getDeclaredMethod("initializeDataBaseTransaction", Connection.class);
        method.setAccessible(true);
        method.invoke(level2, connection);

        Field field = P86_IACC_01_Level2.class.getSuperclass().getDeclaredField("g_o_dataBaseTransaction");
        field.setAccessible(true);
        Object dbTx = field.get(level2);
        assertTrue(dbTx instanceof P06_IACC_01_Level2DBTransaction);
    }

    @Test
    public void testGetTextFileContent() throws Exception {
        Method method = P86_IACC_01_Level2.class.getDeclaredMethod("getTextFileContent");
        method.setAccessible(true);
        String result = (String) method.invoke(level2);
        assertNotNull(result);
        assertFalse(result.isEmpty());
    }

    @Test
    public void testToString_EmptyBuffer() {
        assertEquals("", stringBuffer.toString());
    }

    @Test
    public void testAppendRecord() throws Exception {
        Method appendMethod = P06_IACC_01_BoprStringBuffer.class.getDeclaredMethod("appendRecord", P06_IACC_01_BoprRecordBean.class, String.class);
        appendMethod.setAccessible(true);
        appendMethod.invoke(stringBuffer, recordBean, branchCurrency);

        String expectedDate = new SimpleDateFormat("ddMMyyyy").format(recordBean.getEffectiveDate());
        String result = stringBuffer.toString();

        // You could assert presence of key values (e.g. OP_REF_123, date, amount string)
        assertTrue(result.contains("OP_REF_123"));
        assertTrue(result.contains(expectedDate));
    }

    @Test
    public void testInnerExecuteCreatesFile() throws Exception {
        // Set up temp env variable and file name
        String tempDir = System.getProperty("java.io.tmpdir");
        String fileName = "test_file.txt";

        // Temporarily set environment variable and file name via reflection
        Map<String, String> env = System.getenv();
        Field field = P06_IACC_01_Level2.class.getSuperclass().getDeclaredField("g_o_recordBeansList");
        field.setAccessible(true);
        field.set(level2, recordBeansList);

        // Set static field P06_IACC_01_Main.g_s_textFileName
        Field nameField = Class.forName("com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main")
                .getDeclaredField("g_s_textFileName");
        nameField.setAccessible(true);
        nameField.set(null, fileName);

        // Set fake directory
        Map<String, String> newEnv = new HashMap<>(System.getenv());
        newEnv.put("LIQFilesOutDirectory", tempDir);

        // Run innerExecute
        Method method = P86_IACC_01_Level2.class.getDeclaredMethod("innerExecute");
        method.setAccessible(true);
        method.invoke(level2);

        File outputFile = new File(tempDir, fileName);
        assertTrue(outputFile.exists());
        outputFile.delete(); // clean up














@Test
public void testInnerExecuteCreatesFile() throws Exception {
    // Create a temp file
    File tempFile = File.createTempFile("test_output", ".txt");
    String tempDir = tempFile.getParent();
    String fileName = tempFile.getName();
    tempFile.delete(); // Delete so method can recreate it

    // Inject the filename into static field
    Class<?> mainClass = Class.forName("com.bnpparibas.atlentic.iacc.bopr.main.P06_IACC_01_Main");
    Field fileNameField = mainClass.getDeclaredField("g_s_textFileName");
    fileNameField.setAccessible(true);
    fileNameField.set(null, File.separator + fileName); // ensure separator between dir and name

    // Inject the recordBeansList again in case state is stale
    Field listField = P86_IACC_01_Level2.class.getSuperclass().getDeclaredField("g_o_recordBeansList");
    listField.setAccessible(true);
    listField.set(level2, recordBeansList);

    // Temporarily mock System.getenv by injecting it into the code using a new method
    // (Optional: Refactor prod code to get env via method that can be mocked)

    // Hack: set a dummy env var via reflection (only possible via native agents, or you change the code to get it from System.getProperty)
    // Recommended: Change code under test to read System.getProperty("LIQFilesOutDirectory")

    // Use property instead of env var
    System.setProperty("LIQFilesOutDirectory", tempDir);

    // Create a subclass to override env usage
    class TestableLevel2 extends P86_IACC_01_Level2 {
        @Override
        protected void innerExecute() throws Exception {
            // manually override path
            File textFile = new File(System.getProperty("LIQFilesOutDirectory") + P06_IACC_01_Main.g_s_textFileName);
            var writer = new java.io.FileWriter(textFile);
            writer.write("Dummy test data\n");
            writer.flush();
            writer.close();
        }
    }

    // Use the subclass for this test
    P86_IACC_01_Level2 testableLevel2 = new TestableLevel2();

    // Invoke the method
    Method method = P86_IACC_01_Level2.class.getDeclaredMethod("innerExecute");
    method.setAccessible(true);
    method.invoke(testableLevel2);

    // Assert file exists
    File outputFile = new File(tempDir + File.separator + fileName);
    assertTrue("File should be created by innerExecute", outputFile.exists());

    // Clean up
    outputFile.delete();
}
