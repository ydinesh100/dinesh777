package com.bnpparibas.atlentic.risk.utils;

import com.bnpparibas.atlentic.common.Connexion;
import com.bnpparibas.atlentic.risk.ost.POO_IRSK_03_trace;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.sql.SQLException;

import static com.github.stefanbirkner.systemlambda.SystemLambda.catchSystemExit;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class POO_IRSK_01_ExceptionHandlingUtilTest {

    @Test
    void testPrivateConstructor() throws Exception {
        Constructor<POO_IRSK_01_ExceptionHandlingUtil> constructor =
                POO_IRSK_01_ExceptionHandlingUtil.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        Object instance = constructor.newInstance();
        assertNotNull(instance);
    }

    @Test
    void testUnwrapExceptionWithoutCause() throws Exception {
        Throwable input = new Exception("root");
        Method unwrap = POO_IRSK_01_ExceptionHandlingUtil.class
                .getDeclaredMethod("unwrapException", Throwable.class);
        unwrap.setAccessible(true);

        Throwable result = (Throwable) unwrap.invoke(null, input);
        assertSame(input, result);
    }

    @Test
    void testUnwrapExceptionWithNestedCause() throws Exception {
        Throwable root = new RuntimeException("root");
        Throwable middle = new Exception("middle", root);
        Throwable top = new Exception("top", middle);

        Method unwrap = POO_IRSK_01_ExceptionHandlingUtil.class
                .getDeclaredMethod("unwrapException", Throwable.class);
        unwrap.setAccessible(true);

        Throwable result = (Throwable) unwrap.invoke(null, top);
        assertSame(root, result);
    }

    @Test
    void testLogExceptions_WithSQLException_TriggersExit() throws Exception {
        // Arrange mocks
        POO_IRSK_03_trace trace = mock(POO_IRSK_03_trace.class);
        Connexion connection = mock(Connexion.class);
        SQLException sqlEx = new SQLException("DB error", "42000", 105);

        Method logMethod = POO_IRSK_01_ExceptionHandlingUtil.class.getDeclaredMethod(
                "logExceptions",
                POO_IRSK_03_trace.class,
                String.class,
                String.class,
                Exception.class,
                Connexion.class
        );
        logMethod.setAccessible(true);

        // Act: Catch System.exit
        int status = catchSystemExit(() ->
                logMethod.invoke(null, trace, "Message1", "Message2", sqlEx, connection));

        // Assert
        assertEquals(8, status);
        verify(connection).rollback();
    }

    @Test
    void testLogExceptions_WithGenericException_TriggersExit() throws Exception {
        POO_IRSK_03_trace trace = mock(POO_IRSK_03_trace.class);
        Connexion connection = mock(Connexion.class);
        Exception genericEx = new RuntimeException("Some error");

        Method logMethod = POO_IRSK_01_ExceptionHandlingUtil.class.getDeclaredMethod(
                "logExceptions",
                POO_IRSK_03_trace.class,
                String.class,
                String.class,
                Exception.class,
                Connexion.class
        );
        logMethod.setAccessible(true);

        int exitCode = catchSystemExit(() ->
                logMethod.invoke(null, trace, "LOG1", "LOG2", genericEx, connection));

        assertEquals(8, exitCode);
        verify(trace, atLeastOnce()).Add_log(eq(2), isNull(), eq("Fatal"), contains("LOG2"));
        verify(connection).rollback();
    }
}
