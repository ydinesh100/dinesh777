@RunWith(MockitoJUnitRunner.class)
public class P06_IACC_01_Level1DBTransactionTest {

    @Mock
    private Connection mockConnection;

    @Mock
    private PreparedStatement mockPreparedStatement;

    @Mock
    private ResultSet mockResultSet;

    private P06_IACC_01_Level1DBTransaction transaction;

    @Before
    public void setUp() throws Exception {
        transaction = new P06_IACC_01_Level1DBTransaction() {
            @Override
            protected String getSelectRecordsQueryKey() {
                return "mock.query.key";
            }

            @Override
            protected String getQueryFromProperties(String key) {
                return "SELECT * FROM FAKE_TABLE";
            }

            @Override
            protected void feedRecordsBeansListPreparedStatement(PreparedStatement stmt) {
                // no-op for test
            }

            @Override
            protected void feedingRecordBean(P06_IACC_01_BoprRecordBean bean, ResultSet rs) {
                // simulate population
                bean.setAmount(123.45);
                bean.setDealId("D123");
            }
        };

        // Inject mock connection via reflection
        Field connField = P06_IACC_01_Level1DBTransaction.class.getDeclaredField("g_o_dataBaseConnection");
        connField.setAccessible(true);
        connField.set(transaction, mockConnection);
    }

    @Test
    public void test_getRecordsBeansList_success() throws Exception {
        Mockito.when(mockConnection.prepareStatement(Mockito.anyString())).thenReturn(mockPreparedStatement);
        Mockito.when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
        Mockito.when(mockResultSet.next()).thenReturn(true, false); // only one row

        List<P06_IACC_01_BoprRecordBean> result = transaction.getRecordsBeansList();

        Assert.assertEquals(1, result.size());
        Assert.assertEquals("D123", result.get(0).getDealId());
        Assert.assertEquals(123.45, result.get(0).getAmount(), 0.001);
    }

    @Test
    public void test_getRecordsBeansList_filters_zero_amount() throws Exception {
        transaction = new P06_IACC_01_Level1DBTransaction() {
            @Override
            protected String getSelectRecordsQueryKey() {
                return "mock.query.key";
            }

            @Override
            protected String getQueryFromProperties(String key) {
                return "SELECT * FROM FAKE_TABLE";
            }

            @Override
            protected void feedRecordsBeansListPreparedStatement(PreparedStatement stmt) {
            }

            @Override
            protected void feedingRecordBean(P06_IACC_01_BoprRecordBean bean, ResultSet rs) {
                bean.setAmount(0.0); // Will be filtered
            }
        };

        Field connField = P06_IACC_01_Level1DBTransaction.class.getDeclaredField("g_o_dataBaseConnection");
        connField.setAccessible(true);
        connField.set(transaction, mockConnection);

        Mockito.when(mockConnection.prepareStatement(Mockito.anyString())).thenReturn(mockPreparedStatement);
        Mockito.when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);
        Mockito.when(mockResultSet.next()).thenReturn(true, false);

        List<P06_IACC_01_BoprRecordBean> result = transaction.getRecordsBeansList();

        Assert.assertTrue(result.isEmpty());
    }

    @Test(expected = P86_IACC_01_SQLException.class)
    public void test_getRecordsBeansList_SQLException() throws Exception {
        Mockito.when(mockConnection.prepareStatement(Mockito.anyString()))
               .thenThrow(new SQLException("DB failed"));

        transaction.getRecordsBeansList();
    }
}
